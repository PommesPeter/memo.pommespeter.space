# Chapter2 Data Structure


> Attention：
>
> - 一般在写算法题的时候都是用**数组**来模拟各种数据结构，因为使用结构体每次都要使用 new 创建对象，这个过程非常慢！
> - 算法题一般不用纠结浪费的问题，只需要在特定的时间之内运行完程序就行。
> - 算法题不用纠结空间的问题，目光放在时间上即可。
> - 读字符建议用字符串来读取

## Link List

### Single（邻接表）

- 用得比较多的是邻接表，邻接表用于存储**树和图**。

- 用数组表示的方法：

  1. 创建 `e[N]`数组表示链表中节点的值。
  2. 创建`ne[N]`数组表示链表当前节点的下一个，也就是指向下一个节点的指针。

- 对应关系为

  - 用下标来表示，`e[0]`表示链表中 0 号节点的值，`ne[0]`表示链表中 0 号节点的下一个指向的节点的下标。下图可说明。

    ![image-20220202172253072](src/DataStructure/image-20220202172253072.png)

    **其中，当指向的下一个节点为空时用 -1 表示。**

### Dual

>  主要用于优化，具体看题目。双链表就是有两个指针，一个指向前面，另一个指向后面。

- 规定**下标为 0 的点为头节点**，**下标为 1 的点为最后一个点**

- 用数组的表示方法：

  - 创建 `e[N]`数组表示链表中节点的值。

  - 创建 `l[N]` 和 `r[N]` 分别表示链表当前节点的左指针和右指针，分别指向前一个节点的 idx 和 后一个节点的 idx。（l 表示指向左边的，相当于向左的单链表的 `ne[N}`；r 表示指向右边的，相当于向右的单链表的 `ne[N}`。）

    ![image-20220217221334273](src/DataStructure/image-20220217221334273.png)

    ![image-20220218011014547](src/DataStructure/image-20220218011014547.png)



## Stack

- 普通栈

  **先进后出**

```cpp
const int N = 1e6 + 10;
int tt, stk[N];

void insert(int x) { stk[++tt] = x; }
void remove() { tt--; }
int top() { return stk[tt]; }
bool isEmpty() {
    if (tt > 0)
        return 0;
    else
        return 1;
}
```

- 单调栈

:::tip

思考思路：

1.与双指针类似，先思考暴力做法。

2.在暴力基础上思考可以优化地方，思考有哪些性质。

3.写算法题基本都是用空间换时间。

:::

  典型例题：求一个序列当中每一个数的左边离这个数最近的且比它小的数，不存在返回 -1。

  扫描顺序如图（其中，**绿色**为当前数字，**橙色**为判定区域）：

  ![image-20220219002744026](src/DataStructure/image-20220219002744026.png)

  结果为（**黄色和黑色加粗**为当前数字的结果，也就是绿色格子）：

  ![image-20220219003014076](src/DataStructure/image-20220219003014076.png)

  本题中，定义一个栈来存储左边的元素，每扫描一个元素就往栈当中添加当前元素进来。通过观察栈中元素的性质构造一个单调序列， $a_x \ge a_y$ 且 $x < y$，如果 $a_x$ 作为目标值输出，那么 $a_y$ 也可以输出，所以 $a_x$ 就可以被去掉。满足这个性质点都可以被剔除，这些点是没有用的点，可以删除，最终剩下的点就构成一个单调的序列。

  ![image-20220219005745297](src/DataStructure/image-20220219005745297.png)

  上图中，本质上可以看成划分了多个局部的单调序列。只要出现递减的数，就重新构造单调子序列。

  对于 3 而言，没有左边的元素，所以是 -1；

  对于 4 而言，左边比它小的第一个数为 3， 所以是 3；

  对于 2 而言，没有左边比它小的。所以是 -1；（此时扫描到这个数后，相对于前面的序列已经出现递减，故这里是第二个子序列的开始）

  对于 7 而言，左边比它小的第一个数为 2，所以是 2；

  对于 5 而言，左边比它小的第一个数为 2，所以为 2；（此时扫描到这个数后，相对于前面的序列已经出现递减，故这里是第三个子序列的开始）

  所以，综上可以发现，所求的目标值都是每个单调子序列的第一个元素，使用栈进行存储后即为栈顶元素，栈每次都会存储当正在扫描的元素所在的子序列，当遇到递减的元素后就清空栈，重新记录单调子序列。（本质，构成**逆序对**的点可以被删除。）

## Queue

- 普通队列

  **先进先出**

```cpp
const int N = 1e6 + 10;
// 队尾插入元素，队头弹出元素
int hh, tt = -1, q[N];

void insert(int x) { q[++tt] = x; }
void remove() { hh++; }
int front() { return q[hh]; }
int back() { return q[tt]; }
bool isEmpty() {
    if (hh <= tt)
        return 0;
    else
        return 1;
}
```

- 单调队列

  与单调栈类似，典型例题：滑动窗口，输出每次窗口当中的最值。（计算机网络重要应用）
  
  求最小值：当队列（滑动窗口）当中存在一个比最小的数时，其他的数永远都不可能是最小，也就是其他数字永远都不会当成答案输出（性质）。所以其他数字就可以被剔除。（本质，构成**逆序对**的点可以被删除。）构造出一个单调子序列之后，**最小值会在队头出现**。（最大值同理）
  
  

## KMP

:::tip 思考思路

1. 先思考暴力的做法。
2. 如何优化

:::

对于模板字符串的每一个元素都需要模拟出来一个以某点为终点的后缀，得出相等的最大长度是多少。创建一个 `next[N]` 数组，`next[i]` 表示的含义是**以 i 为终点的后缀**和**从 1 开始的前缀**相等，且后缀的长度最长。其中对于 `next[i] = j` 表示 $p[1, j] == p[i - j + 1, i]$。

![image-20220220021515979](src/DataStructure/image-20220220021515979.png)

使用 next 数组进行匹配，一开始判断 $s[i]$ 是否与 $p[j + 1]$ 相等，如果不相等，则需要通过 next 数组移动模板串的位置，修改 $j$ 的值实现 $j = ne[j]$。如果相等，则继续往后匹配，直到 $j == n$，也就是扫描到模板字符串 p 的末尾说明匹配成功，此时对应起始的点下标就是 $i - n$ ，记得修改 $j$ 的位置，因为匹配成功之后因为已经到达模板串的末尾，通过 next 数组告诉模板串**移动多少距离**可以找到下一个匹配的字符串（j = ne[j]）。

- 求解 next 数组

  两个模板串向右错开一位后，对模板串扫描前缀和后缀相同的部分。

  ![image-20220224111644794](src/DataStructure/image-20220224111644794.png)

- 匹配字符串

  字符串和模板串向右错开一位进行匹配，根据 next 数组的结果扫描前缀与后缀相同的部分。

## Trie

Trie：高效存储和查找字符串集合的数据结构。以字典形式存储。本质为字典树。将数据按照在树中的 DFS 方式存储。也可以叫前缀树，根据前缀一个一个查找。注意每个数据的结束一定要在对应的末尾进行标记，表示数据存在。

:::info

使用的时候注意树的横向和纵向所代表的意思（二维数组的第 1 维和第 2 维的定义，从左往右看），一般来说第 1 维表示位置即层数，第 2 维度仅表示对应的键。使用 DFS 找到对应的数据。

:::

![image-20220224105505723](src/DataStructure/image-20220224105505723.png)

上述 Trie 树表示如下为 aa, aba, ba, cc, cba, cab, caaa。（叶子节点作为结束）

## 并查集

> - 简短且思路精巧，最容易考到，重点！
> - 用于快速维护一些操作
>   1. 将两个集合合并
>   2. 询问两个元素是否在一个集合当中

基本原理：

1. 用树维护一个集合，根节点的编号表示当前集合的编号。每个节点存储它的父节点，p[x] 表示 x 的父节点。

   ![image-20220228191153808](src/DataStructure/image-20220228191153808.png)

   - 判断树根：`if (p[x] == x)`
   - 求 x 的集合编号：`while(p[x] != x) x = p[x];`
   - 合并两个集合：p[x] 是 x 的集合编号，p[y] 是 y 的集合编号。`p[x] = y`

2. 对于上述的优化

   ![image-20220228191421471](src/DataStructure/image-20220228191421471.png)

   - 第一次找到一条路径后，将这条路径上所有的节点都与根节点相连。本质上是路径压缩优化。

```cpp
int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
```

## Heap

>堆常用操作：
>
>1. 插入一个数
>2. 求集合当中的最小值
>3. 删除最小值
>4. 删除任意一个元素
>5. 修改任意一个元素

堆本质是一个完全二叉树，最后一层往上全满，最后一层从左到右依次排列。

小根堆：每一个点都是小于等于左右的节点

大根堆：每一个点都是大于等于左右的节点

存储方式：数组存储，偶数存左节点，奇数存右节点。编号为 $x$ 的节点，左节点编号为 $2x$，右节点编号为 $2x + 1$（下标从 1 开始）

操作（看实际需求决定使用哪个函数）：

- down(x)：将大数 x 沉到树的底部。

  ![image-20220304212653469](src/DataStructure/image-20220304212653469.png)

- up(x)：将小数 x 浮到树的顶部，即根节点。

  ![image-20220304212736779](src/DataStructure/image-20220304212736779.png)

- 插入一个数：`heap[ ++size] = x; up(size);`（在数组后面插入，再将整个堆调整一下）

- 求集合当中的最小值：`heap[1];`（小根堆的根节点为最小值）

- 删除一个最小值：`heap[1] = heap[size]; size--; down(1);`（用最后一个点代替掉根节点，随后再调整堆）

- 删除任意一个元素：`heap[k] = heap[size]; size--; down(k); up(k);`（用最后一个点代替掉第 $k$ 个点，随后上下调整堆）

- 修改任意一个元素：`heap[k] = x; down(k); up(k);`（更新第 $k$ 个点，随后上下调整堆）

`down` 和 `up` 操作：

```cpp
```



## Hash Map
