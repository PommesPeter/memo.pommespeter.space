---
tags:
    - BasicAlgorithm
---



#  好用算法 Trick

## 很大的数

表示一个很大的数，看类型包含多少字节写多少个 `3f`。

:::info

$(3f)_{16}=(0111\ 1111)_2$

:::

```cpp
const int N = 0x3f3f3f3f;
```

## 建图

### 邻接表

```cpp
const int N = 1e5 + 10, M = 2e5 + 10;
int h[N], e[M], ne[M], idx;

void add (int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
}   
```

### 邻接矩阵

```cpp
int g[N][N];

for (int i = 0; i < m; i++) {
    g[a][b] = g[b][a] = min(g[a][b], c); // 无向图
    g[a][b] = min(g[a][b], c); // 有向图
}
```

### DFS（深度优先遍历）

```cpp
void dfs(int u, ...) { // ... 处可以加入下一层更新的参数
    st[u] = true;
    // ... 可填代码（往下层遍历之前的操作，可计数blahblah等操作）
    for (int i = 0;i < v[u].size(); i++) {
        int j = v[u][i]; //邻接表存，其值表示节点编号
		if (!st[u]) {
            // ... 前序
            dfs(j, ....);
            // ... 后序
        }
    }
    // ... 如果有返回值可以在这里返回
}
```

### DFS（深度优先搜索）

```cpp
void dfs(int u, ...) {
    if (u == n) return ; // 结束条件不唯一
    
    // ... 可做遍历前预处理，例如剪枝等
    
    for (int i = 0; i < n; i ++) {
        int j = g[u][i]; // 邻接矩阵存，值代表边权，i为节点编号
        if (!st[i] && ...) { // ... 处代表满足什么条件才往下搜
            // 记录现场，表示访问过，下次不在访问
            st[u] = true;
            dfs(i, ...);
            // 上一次的遍历结束了，开始遍历下一种情况，恢复现场
            st[u] = false;
        }
    }
}
```



### BFS





